# 散列

散列表的实现常常叫做散列.**散列**是一种用于以常数平均时间执行插入,删除和查找的技术.但是那些需要元素间任何排序信息的树操作将不会得到有效的支持.

理想的**散列表**数据结构是包含一些项的具有固定大小的数组. 表的大小记为TableSize.通常查找是对项的每个数据域进行的.每个关键字被映射到0到TableSize-1这个范围
的某个数,并且被放到合适的单元中. 这个映射就叫做散列函数(hash function).

**散列函数**理想情况下应该计算起来简单,并且应该保证任何两个不同的**关键字**映射到不同的单元.不过这是不可能的,因为单元的数目是有限的.

**冲突** : 当两个**关键字**映射到相同的值的时候就叫作发生了**冲突**.

## 分离链接法

解决冲突的第一种方法通常叫做**分离链接法**(separate chaining),其做法是将散列到同一个值的所有元素保留到同一个表里.

为了执行一次查找,我们使用散列函数确定究竟遍历哪个链表.然后再被确定的链表中执行一次查找.为了执行insert,我们检查相应的链表看看该元素是否已在链表中,
如果不存在,则将它插入链表的前端.

## 线性探测法

分离散列表算法的缺点是使用一些链表,由于给新单元分配地址需要时间,这就导致算法速度有些减慢.

有一种不用链表解决问题的方法是尝试另外一些单元,知道找出空的单元为止.更常见的情况是h1(x),h2(x),...相继被试选,其中 hi(x) = (hash(x) + f(i))mod TableSize.
且f(0) = 0. 函数f是冲突解决办法.因为所有数据都要置于表内,所以这种解决方案所需要的空间比分离链接散列的空间要大.

对于不同分离链接的散列表来说哦,其装填因子lambda应该低于0.5. 我们把这样的表叫做**探测散列表**(probing hash table).

### 双散列

对于双散列,一种流行的方法是 f(i) = i*hash2(x).

## 再散列

对于使用平方探测的开放定址散列法,如果散列表填的太满,那么操作的运行时间将开始消耗过长,且插入操作可能失败.此时.
另一种解决方法是建立另外一个大约两倍大的表(而且使用一个相关的新的散列函数),扫描整个原始表,计算每个(未删除的)元素
的新散列之并将其插入到新表中.整个操作就叫做**再散列**.

**途中策略(middle-of-the-road)**: 当散列表到达某一个装填因子时进行再散列.由于随着装填银因子的增长散列表的性能
确实下降,因此,好的截至手段可能就是**途中策略**.



