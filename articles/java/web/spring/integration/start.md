# Spring Integration Overview

## 5.1 背景

Spring 框架的核心主题时控制反转(Inversion of Control)(IOC)。宽泛的理解，这意味着框架代表在上下文里管理的组件处理责任。例如，依赖注入将组件从定位或者创建依赖中解脱出来。同样地，面向切面地编程将通用的跨切面考虑的事务组件解脱出来，通过将它们模块化为可从用的切面。每种情况，最终的结果都是一个更加易于测试，理解，维护扩展的系统。

除此之外，Spring框架和组合为构建企业级应用提供了一个易于理解的编程模型。开发者受益于模型的持续性和它基于最好的实践建立的事实，例如对接口编程和赞成混合而不是继承。Spring简化了抽象和强大的支持库，增加了开发者的生产力，同时增加了可测试性和轻便性。

Spring 集成由这些相同的目标和原则促进。 它扩展了 Spring 编程模型到消息域，构建在 Spring 已存在的企业级集成支持之上，来提供一个更高层的抽象。它支持消息驱动的结构，控制反转应用在运行时的关注点，例如，当特定的事务逻辑应该运行，并且响应应该被发送。它支持路由和消息转换，因此不同的运送和不同的数据格式应该被集成，而不影响测试性。换句话说，由框架来处理消息和集成考虑。事务组件因此从基础架构中孤立出来，开发者从复杂的集成责任中解放出来。

作为 Spring 编程模型的扩展，Spring集成提供了很多种配置选项，包括标记，XML与命名空间支持，XML与通用的 bean 元素，直接使用下面的API。这些 API 是基于定义好的策略接口并且是非侵入性的， 委托适配器。 Spirng Integration 的设计被 [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/)中描述的著名的设计模式和 Spirng 与常用的设计模式之间强相关性的识别所启发。阅读过该书的开发者应该立刻对 Spring Integration 的概念和科技感到舒适。

## 5.2 目标和原则

Spring Integration 由下列目标所推动：

- 提供实现复杂的企业级集成解决方案的简单模型。

- 在基于 Spring 的应用中简化和便利异步的，消息驱动的行为

- 为已存在的 Spring 用户提供易于理解的，递增的采纳方法。

Spring Integration 由下列原则知道:

- 组件为了模块性和可测试性应该稀松耦合。

- 框架应该在事务逻辑和集成逻辑之间强迫关注点分离。

- 扩展点对于促进重用和便携性来说应该自然抽象。

## 5.3 主要组件

从垂直的方面，一个层级的架构减轻了关注点分离的困难，在层级之间基于接口的契约促进了稀疏耦合。基于 Spring 的应用典型地设计为这种方式，Spring fremework 和组合为企业级应用的全栈追随最好的实践提供了一个强大的基础。消息驱动的架构添加了一个水平角度，但是这些相同的目标依然是相关的。就像层级架构是一个极其通用的抽象的范例，消息系统典型的遵循了相似的抽象模型 “管道-过滤”(pipes-and-filters)。 这些 “过滤器” 代表任意有能力生产和消费信息的组件。“管道”在过滤器之间传输消息，因此组件之间保持稀松耦合。很重要地，注意到这些两个高度地范例是互相之间不排外地。下方的消息基础架构支持“管道”应该被封装到一个层级，由接口定义的契约约束。同样的，过滤器自己也应该在一个层级之间被管理，逻辑上在应用服务层之上，通过接口与这些服务交互就像网络层级(tier)一样。

### 5.3.1 消息

在 Spring Integration中，一个消息是一个任意 Java 对象的通用的封装，结合了框架使用的元数据。 它包含了一个负载和头部。这个负载可以是任意类型，并且头部保存常用的需要的信息例如ID,时间戳，纠正ID，和返回地址。头部同样被使用，当传递值在互相连接的传送点之间。例如，当从一个接收到的文件创建一个消息，这个文件名可能存储在一个头部，可以被下流组件进入。同样的，如果一个消息的内容是最终要被发送通过一个出口的邮件适配器，各种属性(to,from,cc,subject, and others)可能被配置为一个消息头值通过一个上传流组件。开发者同样可以在头部存储任意地键值对。

![Message](/img/Message.png)

### 5.3.2 消息频道(Message Channel)

一个消息频道代表“管道-过滤器”架构中的“管道”。生产者发送消息到一个频道，消费者从频道中就接收消息。这些消息频道因此结构了消息组件，同样提供了一个便利点在解释和掌控消息。

一个消息频道可能会遵循 **点对点** 或者 **出版-订阅** 的语义。在一个 **点对点** 频道中，不超过一个消费者能够从接收到每个发送到频道中的消息。**出版-订阅** 频道，另一方面，尝试广播每个消息给在频道上所有的订阅者。 Spring Integration 同时支持这两个模型。

当 **点对点** 和 **出版-订阅** 定义了多少消费者最终接受到每个消息的选项，有很重要的一点需要考虑: 频道应该缓存消息吗？ 在 Spring Integration 中，可投票的频道能够在一个队列中缓存消息。缓存的优点是它允许入站消息的瓶颈并且因此阻止消费者超负载。然而，正如名字暗示的，这同样增加了复杂性，因为每个消费者只能接受消息从这样一个频道如果一个投票器配置。另一方面，一个连接到订阅者频道的消费者是简单的消费驱动的。 消息频道的实现有一个详细的讨论关于 Spring Integration 中可获取的频道实现。

### 5.3.3 消息终点

Spring Integration 的一个主要的目标是通过控制反转简化企业级集成解决方案的开发。这意味着你不必直接实现消费者或者生产者，你甚至不用构建消息和调用发送或者接受操作在一个消息频道上。作为替代，你应该能够专注于你的特定域模型通过一个基于普通对象的实现。然后，通过提供声明式配置，你能够连接到你的域定义的代码到 Spring Integration 提供的消息基础设施。负责这些链接的组件是消息重点。这不意味着你应该必要地直接连接到你的已存在的代码。现实企业中的集成解决方案需要相当多的代码在集成考虑上例如路由和转换。重要的事情是实现集成逻辑和事务逻辑之间的关注点的分离。换句话说，就像 web 应用中的 Model-View-Controller(MVC)范例，目标应该提供一个瘦的专注的层来转换入站请求到服务层调用，然后转换服务层返回值到出站回复。下一节提供消息终点类型处理这些责任的总览，在即将到来的章节中，你可以看到 Spring Integration 的声明式配置选项提供了非侵入式的方式来使用这些。

## 5.4 消息终点

一个消息终点代表 “管道-过滤器” 架构中的 “过滤器”。 正如之前提到的，终点的主要角色是连接应用代码到消息框架，并且以一种非侵入的方式。换句话说，应用代码理想的意识不到消息对象或者消息频道的存在。这相似于 MVC 范例中的 controller。 就像一个 controller 处理 HTTP 请求， 消息终点处理消息。就像 controller 映射到 URL 地址， 消息端点映射到消息频道。 这个目标在两种情况下都相同：从基础架构中孤立应用代码。这些概念和所有模式遵循 Enterprise Integration Patterns 中讨论的。这里我们提供 Spring Integration 支持的端点类型的高度描述和这些类型关联的角色。 这一节遵循详细说明，像配置示例一样提供示例代码。

### 5.4.1 消息转换

一个消息转换有责任转换一个消息内容或者结构，返回修改的消息。可能转换器的最常用的类型是转换消息负载从一个格式到另一种(例如从XML到java.lang.String)。相似的，一个转换器可以添加，移除，和修改消息头部的值。

### 5.4.2 消息过滤

一个消息过滤器决定了一个消息是否应该传递给一个输出频道。这简化了需要一个布尔测试方法来检查特定的负载内容类型，头部的存在性，或者其他应用。如果一个消息接受，它被发送到输出频道。如果不接受，它被丢掉(或者，更严格的实现，一个异常被抛出)。消息过滤器经常被使用，结合出版订阅频道，当多个消费者接收到相同的消息，使用过滤器产品来缩小下面的要处理的消息。

### 5.4.3 消息路由

一个消息路由有责任决定什么频道或者哪些频道应该接受到消息文本。典型的，这个决定基于消息内容和消息头中可获得的源数据类型。一个消息路由经常被用作动态的替换静态配置的输出频道在一个服务催化剂上或者其他端点有能力发送响应消息。同样的，一个消息路由提供一个积极的替代反应式消息过滤器被多个订阅者使用的。

### 5.4.4 Splitter 分离器

一个分离器是另一种消息端点有责任接受消息从它的输入频道，分离消息到多个消息，发送这些的每一个到他的输出频道。这典型的被用来分离一个组合的负载对象到一组消息包含细分的负载。

### 5.4.5 聚合器 Aggregator

基础的一个分离器的镜像，聚集器是一种消息端点类型接受多个消息，并结合他们到单个消息。事实上，聚集器通常是下行流的消费这在一个管道里包含一个分离器。科技上，聚集起比分离器更复杂，因为它需要维持状态(j聚集的消息),来决定当完整的一组消息可获得时，到当必要时的超时。除此之外，为了防止超时，聚集器需要知道是否发送部分结果，遗弃它们，或者发送它们到单独的频道。Spring Integration 提供了一个 CorrelationStrategy，一个 ReleaseStrategy，和超时的配置设置，是否发送超时的部分结果，或者遗弃消息。

### 5.4.6 服务激活器

一个服务激活器是一个通用的端点来连接服务实例到消息系统。输入的消息频道必须是配置的，如果服务方法调用，有能力返回一个值，一个输出消息频道同样被提供。

输出频道是可选的，因为每个消息同样提供了它自己的返回地址头部。这个相同的规则应用到所有消费者端点。

服务催化器调用一些服务对象的操作来处理消息，提取请求消息的负载并且转换(如果方法不期待消息类型的参数)。无论何时服务对象方法返回一个值，返回值同样的被转换为一个返回消息如果必要的话(如果已经不是一个消息类型)。回复消息被发送到输出频道。如果没有已经配置的输出频道，响应发送到消息返回地址中明确的频道。

一个请求回复服务催化剂端点连接一个目标对象方法来输入和输出消息频道。

### 5.4.7 频道适配器

一个频道适配器是一个端点




