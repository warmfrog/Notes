# OAuth 学习笔记

[学习文档地址](https://oauth.net/)
推荐地址<https://www.oauth.com>

OAuth2.0: 一个开放协议允许用一种简单标准的方法在web,手机和桌面应用上进行安全授权.

OAuth2.0认证框架允许第三方应用获得有限的访问到web服务.

OAuth 是一个简单的方式出版和交互想要保护的数据.它也更安全并且以很安全的方式给用户访问权限.

如果你保存受保护的数据代表用户,不能仅仅为了得到访问权限,就让数据在网上传播. 使用OAuth给你访问数据的权限从而保护用户凭证.

## [起步(Gettting Started)](https://oauth.net/getting-started/)

### [OAuth2 简化](https://aaronparecki.com/oauth-2-simplified/#roles)

这篇博文以简单的形式描述OAuth2.0 来帮助开发者和服务提供者实现协议.

[OAuth2说明(OAuth2 spec)](https://oauth.net/2/)

### 角色

#### 第三方应用:"客户端"(The Third-Party Application: "Client")

客户端(Client)是应用尝试获得用户账户的进入权限(access). 在它可以这样做之前需要获得用户的允许.

#### The API:"资源服务器" (The API: "Resource Server")

资源服务器是API服务器被用来获取用户信息

#### 认证服务器(The API: "Resource Server")

这是表示用户赞成或拒绝请求的界面显示的服务器. 在更小的实现中, 这可能和API服务器是同一台服务器, 但是更大范围的部署通常构建为分开的组件.

#### 用户:"资源拥有者"(The User: "Resource Owner")

资源拥有者是一个人,这个人将它们账户的权限赋给一些应用.

#### 创建一个App(Creating an app)

在你开始OAuth过程之前,你必须使用服务首先注册一个新的app.当注册一个新的app时,通常你要注册应用名,网站,logo,等等. 除此之外,你必须注册一个重定向URI 被用来重定向用户到web服务器,浏览器或者移动app.

#### 重定向URIs (Redirect URIs)

这个服务只会重定向用户到注册的URI, 这阻止了一些攻击. 任何HTTP重定向地址必须使用TLS安全保护,所以服务指挥被重定向到"https"开头的网址. 这阻止了tokens在认证过程中被拦截. 原生app必须注册一个重定向URI使用应用的自定义URL形式, 就像 demoapp://redirect

#### 客户端id和密匙(Client ID and Secret)

在注册你的app之后,你会收到一个客户端ID和客户端密匙.这个客户端ID被认为是公共信息,被用来构建登录地址,或者包含在页面中的javascipt源代码中. 客户端密匙必须是秘密的. 如果部署一个app不能保证密匙私密, 比如单页JavaScript app 和原生app, 那么密匙不会被使用, 理想的服务不应该放出密匙对这种类型的app.

#### 认证(Authorization)

OAuth2 的第一步是从用户获得认证. 从基于浏览器的或者基于手机app的,这通常由服务提供给用户一个显示接口来完成.

OAuth2为不同的用例提供了几个不同的准许类型(grant types). 准许类型定义如下:

* 认证码(Authorization Code),为运行在web服务器,基于浏览器和手机app的应用.
* 密码,使用用户名和密码登录
* 客户端凭证(Client credential),应用入口
* 隐式(Implicit),已经获得认证码准许授权的,不需要使用密码.

#### web服务器应用(Web Server Apps)

Web服务器应用是最常见的应用类型当你使用OAuth服务器处理的时候. Web 应用写成服务端的语言运行在服务端,应用的源代码不对公众开放.这意味着应用能够使用它自己的客户端密匙与认证服务器沟通, 可以避免一些攻击向量(attck vectors).

#### 授权

创建一个登录连接发送用户到:

```html
https://authorization-server.com/auth?response_type=code&
  client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx
```

* response_type=code- 暗示你的服务器接收到的认证码
* client_id- 当你创建应用的时候得到的client ID
* redirect_uri- 表示认证完成后要将用户发送的地址
* scope- 一个或多个范围(scope)按时你希望进入用户账户的那些部分
* state- 你的应用生成的随机字符串,之后你会用来验证

用户看到下面的认证提示

![oauth-authorization-prompt.png](img/oauth-authorization-prompt.png)

如果用户点击允许(allow),服务使用认证码(auth code)会重定向用户到你的站点

`https://example-app.com/cb?code=AUTH_CODE_HERE&state=1234zyx`

* code-  服务器在查询字符串中返回认证码
* state- 服务器返回你传递的相同状态值

你应该首先比较状态值确保它匹配你开始的. 典型的你可以保存状态值在cookie或session中,当用户返回的时候进行比较. 这确保你的重定向终点不会被任意的认证码糊弄.

#### Token Exchange

你的服务器用认证码交换一个入口token

```text
POST https://api.authorization-server.com/token
  grant_type=authorization_code&
  code=AUTH_CODE_HERE&
  redirect_uri=REDIRECT_URI&
  client_id=CLIENT_ID&
  client_secret=CLIENT_SECRET
  ```

* grant_type=authorization_code 这个流的准许类型是authorization_code
* code=AUTH_CODE_HERE - This is the code you received in the query string
* redirect_uri=REDIRECT_URI - Must be identical to the redirect URI provided in the original link
* redirect_uri=REDIRECT_URI - Must be identical to the redirect URI provided in the original link
* client_secret=CLIENT_SECRET - Since this request is made from server-side code, the secret is included

服务器响应一个access token 和过期时间

```
client_secret=CLIENT_SECRET - Since this request is made from server-side code, the secret is included
```

或者错误

```
{
  "error":"invalid_request"
}
```

### 单页应用

单页应用(或基于浏览器的应用)从网页获取源代码后完全运行在浏览器. 应为完整的源代码完全可以被浏览器获得, 它们不能维持客户端密匙的可信状态, 因此密匙不能在这种情况下使用,. 当认证码经过上述的时候流完全相同,但最后一步, 用认证码交换 access token的时候没有使用client secret.

#### 认证

创建一个发送给用户的登录连接

```html
https://authorization-server.com/auth?response_type=code&
  client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx
```

* response_type=code - Indicates that your server expects to receive an authorization code
* client_id - The client ID you received when you first created the application
* redirect_uri - Indicates the URI to return the user to after authorization is complete
* scope - One or more scope values indicating which parts of the user's account you wish to access
* state - A random string generated by your application, which you'll verify later

### 手机app

像基于浏览器的app一样,手机app同样不能维持客户端密匙的可信度.因为这样,手机app必须同样使用一个不需要客户端密匙的OAuth 流. 有一些另外的考虑: 手机app应该牢记确保OAuth流的安全性

#### 认证

创建一个登录按钮将用户发送到服务在手机上的原生应用上,或者服务的手机web页面. 在iPhone上,apps可以注册一个自定义的URI例如facebook://, 所以原生的facebook app启动当一个URL使用那个协议访问时.在Android上, app可以注册URL 匹配模式, 如果URL匹配,原生app会被访问.

##### 使用原生的app

如果用户安装了原生的app,重定向到下列地址

```html
fbauth2://authorize?response_type=code&client_id=CLIENT_ID
  &redirect_uri=REDIRECT_URI&scope=email&state=1234zyx
```

* response_type=code - indicates that your server expects to receive an authorization code
* client_id=CLIENT_ID - The client ID you received when you first created the application
* redirect_uri=REDIRECT_URI - Indicates the URI to return the user to after authorization is complete, such as fb00000000://authorize
* scope=email - One or more scope values indicating which parts of the user's account you wish to access
* state=1234zyx - A random string generated by your application, which you'll verify later

For servers that support the PKCE extension (and if you're building a server, you should support the PKCE extension), you'll also include the following parameters. First, create a "code verifier" which is a random string that the app stores locally.

* code_challenge=XXXXXXX - This is a base64-encoded version of the sha256 hash of the code verifier string
* code_challenge_method=S256 - Indicates the hashing method used to compute the challenge, in this case, sha256.

Note that your redirect URI will probably look like fb00000000://authorize where the protocol is a custom URL scheme that your app has registered with the OS.

## Other Grant Types

### Password

OAuth 2 also provides a "password" grant type which can be used to exchange a username and password for an access token directly. Since this obviously requires the application to collect the user's password, it must only be used by apps created by the service itself. For example, the native Twitter app could use this grant type to log in on mobile or desktop apps.

To use the password grant type, simply make a POST request like the following:

```
POST https://api.authorization-server.com/token
  grant_type=password&
  username=USERNAME&
  password=PASSWORD&
  client_id=CLIENT_ID
```

* grant_type=password - The grant type for this flow is password
* username=USERNAME - The user's username as collected by the application
* password=PASSWORD - The user's password as collected by the application
* client_id=CLIENT_ID - The client ID you received when you first created the application

The server replies with an access token in the same format as the other grant types.

Note, the client secret is not included here under the assumption that most of the use cases for password grants will be mobile or desktop apps, where the secret cannot be protected.

## <https://oauth.com>学习

* Getting Ready <https://www.oauth.com/oauth2-servers/getting-ready/>
* Accessing Data in an Oauth Server <https://www.oauth.com/oauth2-servers/accessing-data/>

* [Secure a Spring Microservices Architecture with Spring Security and OAuth 2.0](https://developer.okta.com/blog/2018/02/13/secure-spring-microservices-with-oauth)

* [Secure a Spring Microservices Architecture with Spring Security and OAuth 2.0](https://developer.okta.com/blog/2017/08/08/secure-spring-microservices)
